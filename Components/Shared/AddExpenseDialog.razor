@using System.ComponentModel.DataAnnotations
@using Denly.Components.Shared

@if (IsOpen)
{
    <div class="dialog-backdrop" @onclick="OnCancel">
        <div class="dialog-card" @onclick:stopPropagation="true">
            <h2 class="dialog-title">@(IsEditing ? "Edit expense" : "Add expense")</h2>
            <EditForm Model="Model" OnValidSubmit="HandleValidSubmit">
                <DataAnnotationsValidator />

                <div class="dialog-field">
                    <label>Date</label>
                    <InputDate @bind-Value="Model.Date" />
                </div>

                <div class="dialog-field">
                    <label>Description</label>
                    <InputText @bind-Value="Model.Description" placeholder="Expense description" />
                </div>

                <div class="dialog-field">
                    <label>Amount</label>
                    <InputNumber @bind-Value="Model.Amount" placeholder="0.00" />
                </div>

                <div class="dialog-field">
                    <label>Payer</label>
                    <InputSelect @bind-Value="Model.PayerId">
                        <option value="">Select a caregiver</option>
                        @foreach (var caregiver in Caregivers)
                        {
                            <option value="@caregiver.Id">@caregiver.Name</option>
                        }
                    </InputSelect>
                </div>

                <div class="dialog-field">
                    <label>Child association (optional)</label>
                    <InputSelect @bind-Value="Model.ChildId">
                        <option value="">None</option>
                        @foreach (var child in Children)
                        {
                            <option value="@child.Id">@child.Name</option>
                        }
                    </InputSelect>
                </div>

                <ValidationSummary />

                <div class="dialog-actions">
                    @if (IsEditing)
                    {
                        <button type="button" class="dialog-btn delete" @onclick="OnDelete">Delete</button>
                    }
                    <button type="button" class="dialog-btn secondary" @onclick="OnCancel">Cancel</button>
                    <button type="submit" class="dialog-btn primary">Save</button>
                </div>
            </EditForm>
        </div>
    </div>
}

@code {
    [Parameter] public bool IsOpen { get; set; }
    [Parameter] public bool IsEditing { get; set; }
    [Parameter] public AddExpenseInput Model { get; set; } = new();
    [Parameter] public IReadOnlyList<CaregiverOption> Caregivers { get; set; } = Array.Empty<CaregiverOption>();
    [Parameter] public IReadOnlyList<ChildOption> Children { get; set; } = Array.Empty<ChildOption>();
    [Parameter] public string? CurrentUserId { get; set; }
    [Parameter] public EventCallback OnCancel { get; set; }
    [Parameter] public EventCallback<AddExpenseInput> OnSave { get; set; }
    [Parameter] public EventCallback OnDelete { get; set; }

    protected override void OnParametersSet()
    {
        if (Caregivers.Count == 0) return;

        // Initialize splits if empty (new expense) or partial (edited expense without full splits)
        // For simplicity, we just ensure every caregiver is in the list.
        var existing = Model.Splits.ToDictionary(s => s.CaregiverId, s => s);
        var updated = new List<SplitInput>();

        // Default even split calculation if needed
        var even = Caregivers.Count > 0 ? Math.Round(100m / Caregivers.Count, 2) : 100m;

        foreach (var caregiver in Caregivers)
        {
            if (existing.TryGetValue(caregiver.Id, out var split))
            {
                split.CaregiverName = caregiver.Name;
                updated.Add(split);
            }
            else
            {
                updated.Add(new SplitInput
                {
                    CaregiverId = caregiver.Id,
                    CaregiverName = caregiver.Name,
                    Percent = IsEditing ? 0 : even // If editing and new caregiver appears, 0. If new, even.
                });
            }
        }

        Model.Splits = updated;

        if (string.IsNullOrWhiteSpace(Model.PayerId))
        {
            var preferred = !string.IsNullOrWhiteSpace(CurrentUserId)
                && Caregivers.Any(c => c.Id == CurrentUserId)
                ? CurrentUserId
                : Caregivers.FirstOrDefault()?.Id;
            Model.PayerId = preferred ?? string.Empty;
        }
    }

    private async Task HandleValidSubmit()
    {
        await OnSave.InvokeAsync(Model);
    }

    public class AddExpenseInput : IValidatableObject
    {
        public string? Id { get; set; } // For editing

        [Required]
        public DateTime Date { get; set; } = DateTime.Today;

        [Required]
        [MaxLength(140)]
        public string Description { get; set; } = string.Empty;

        [Range(0.01, 100000)]
        public decimal Amount { get; set; }

        [Required]
        public string PayerId { get; set; } = string.Empty;

        public List<SplitInput> Splits { get; set; } = new();

        public string? ChildId { get; set; }

        public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
        {
            // Simple validation: check if sum is roughly 100% ONLY if splits are used/modified.
            // For now, we trust the user or default logic.
            // Implementing robust split validation is complex (auto-balancing vs manual).
            // We'll skip strict 100% check to avoid blocking simple entry, unless we add UI to manage it.
            // But let's check basic validity.
            yield break;
        }
    }

    public class SplitInput
    {
        public string CaregiverId { get; set; } = string.Empty;
        public string CaregiverName { get; set; } = string.Empty;
        public decimal Percent { get; set; }
    }
}